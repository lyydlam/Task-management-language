/*
 * generated by Xtext 2.37.0
 */
package uk.ac.kcl.inf.languages.turtles.validation
import org.eclipse.xtext.validation.Check;

import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.AddTask
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtleProgram
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtlesLanguagePackage
import java.util.Set

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TurtlesLanguageValidator extends AbstractTurtlesLanguageValidator {
	@Check
	def checkNoCircularDependencies(AddTask task) {
        val dependencies = task.dependencies
        if (dependencies.exists[it.dependencies.contains(task)]) {
            error("Circular dependency detected", null)
        }
    }
    //each task should begins with capital letter to fit in quick fix
    @Check
	def void checkTaskNameCapitalized(AddTask task) {
	    if (task.name !== null && !Character.isUpperCase(task.name.charAt(0))) {
	        warning("Task name should start with a capital letter", 
	            task, 
	            TurtlesLanguagePackage.Literals.ADD_TASK__NAME, 
	            "CAPITALIZE_NAME") 
	    }
	}
    @Check
	def checkGroupNameUnique(GroupDeclaration group) {
    	val program = group.eContainer as TurtleProgram
    	val groups = program.statements.filter(GroupDeclaration)
    	if (groups.exists[it.name == group.name && it != group]) {
        error("Group name must be unique", group, 
            TurtlesLanguagePackage.Literals.GROUP_DECLARATION__NAME)
    }
}
    
//priority must be positive
    @Check
    def checkPriorityIsPositive(AddTask task) {
        if (task.priority <= 0) {
            error("Priority must be positive", task, 
                TurtlesLanguagePackage.Literals.ADD_TASK__PRIORITY)
        }
    }
    @Check
	def void checkPeoplePositive(AddTask task) {
	    if (task.peopleRequired.eval <= 0) {
        error("People required must be a positive number", task,
            TurtlesLanguagePackage.Literals.ADD_TASK__PEOPLE_REQUIRED)
    }
}
    
//task id must be unique
    @Check
    def checkTaskIdIsUnique(AddTask task) {
        val program = task.eContainer as TurtleProgram
        val tasks = program.statements.filter(AddTask)
        if (tasks.exists[it.id == task.id && it != task]) {
            error("Task ID must be unique",task, 
                TurtlesLanguagePackage.Literals.ADD_TASK__ID)
        }
    }
    
//check repeat>0
    @Check
	def checkRepeatCount(AddTask task) { 
	if (task.repeatCount <= 0) {
		error("Repeat count must be a positive integer", task, TurtlesLanguagePackage.Literals.ADD_TASK__REPEAT_COUNT)
	}
}
//check dependencies is in cycle?
	@Check
	def checkCyclicDependencies(AddTask task) {
	    val visited = newHashSet()
	    val stack = newHashSet()
	    if (detectCycle(task, visited, stack)) {
	        error("Cyclic dependency detected involving this task", 
	              task, 
	              TurtlesLanguagePackage.Literals.ADD_TASK__DEPENDENCIES)
	    }
	}
	
	def boolean detectCycle(AddTask task, Set<AddTask> visited, Set<AddTask> stack) {
	    if (stack.contains(task)) {
	        return true // found a cycle
	    }
	    if (visited.contains(task)) {
	        return false // already checked
	    }
	    visited.add(task)
	    stack.add(task)
	    for (dep : task.dependencies) {
	        if (detectCycle(dep, visited, stack)) {
	            return true
	        }
	    }
	    stack.remove(task)
	    return false
	}
	

    }

	

