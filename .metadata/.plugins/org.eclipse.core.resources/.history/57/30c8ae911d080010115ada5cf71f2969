/*
 * generated by Xtext 2.37.0
 */
package uk.ac.kcl.inf.languages.turtles.scoping


import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtleProgram
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.QualifiedName
import static org.eclipse.xtext.scoping.Scopes.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.AddTask
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.GroupRefExpression
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.GroupDeclaration
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtlesLanguagePackage
import org.eclipse.xtext.scoping.Scopes

/**
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class TurtlesLanguageScopeProvider extends AbstractDeclarativeScopeProvider {
	//解析 `IntVarExpression` 变量引用，确保变量在作用域内
	override IScope getScope(EObject context, EReference reference) {
        // 为 depends on 和 status of 提供作用域支持
        if (reference == TurtlesLanguagePackage.Literals.ADD_TASK__DEPENDENCIES ||
            reference == TurtlesLanguagePackage.Literals.TASK_STATUS__TASK) {

            val program = context.getContainerOfType(TurtleProgram)
            if (program !== null) {
                val tasks = program.statements.filter(AddTask)
                return scopeFor(tasks, [AddTask t |QualifiedName.create(t.id)])
            }
        }
        return super.getScope(context, reference)
    }


    //"people DevTeam + 1"
    def IScope scope_GroupRefExpression_group(GroupRefExpression context, EReference ref) {
    val program = context.getContainerOfType(TurtleProgram)
    return scopeFor(program.statements.filter(GroupDeclaration))
}
    

}

  

