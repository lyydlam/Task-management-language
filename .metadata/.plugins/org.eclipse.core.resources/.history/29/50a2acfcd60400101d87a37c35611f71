/*
 * generated by Xtext 2.37.0
 */
package uk.ac.kcl.inf.languages.turtles.scoping;

import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.IntVarExpression
import static extension org.eclipse.xtext.EcoreUtil2.*
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.LoopStatement
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.impl.VariableDeclarationImpl
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtleProgram
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.VariableDeclaration
import org.eclipse.emf.ecore.EObject

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class TurtlesLanguageScopeProvider extends AbstractTurtlesLanguageScopeProvider {
	def IScope scope_IntVarExpression_var (IntVarExpression context, EReference ref) {
        val containingLoopStatement = context.getContainerOfType(LoopStatement)

        if (containingLoopStatement !== null) {
            scopeFor(containingLoopStatement.visibleVariablesScope)
        } else {
            val containingProgram = context.getContainerOfType(TurtleProgram)
            scopeFor(containingProgram.statements.filter(VariableDeclaration))
        }
    }

    def IScope visibleVariablesScope(EObject context) {
        if (context instanceof LoopStatement) {
            scopeFor(context.statements.filter(VariableDeclaration), context.eContainer.visibleVariablesScope)
        } else if (context instanceof TurtleProgram) {
            scopeFor(context.statements.filter(VariableDeclaration))
        }
    }
}