/*
 * generated by Xtext 2.37.0
 */
package uk.ac.kcl.inf.languages.turtles.generator

import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.AddTask
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TimeCalculation
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TaskStatus
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtleProgram
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.IntLiteral
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.GroupRefExpression
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.Addition
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.Multiplication


/**
 * 负责生成代码（如任务调度逻辑、时间计算等）
 * 代码生成器
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtlesLanguageGenerator extends AbstractGenerator {

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        if (resource.contents.empty || !(resource.contents.head instanceof TurtleProgram)) {
        println("Error: No TurtleProgram found in resource " + resource.URI)
        return
    }
        val program = resource.contents.head as TurtleProgram
        fsa.generateFile(deriveTargetFileNameFor(program, resource), program.doGenerate)
    }

    def deriveTargetFileNameFor(TurtleProgram program, Resource resource) {
        resource.URI.appendFileExtension('txt').lastSegment
    }

    def String doGenerate(TurtleProgram program) '''
        Program contains:
        - «program.eAllContents.filter(AddTask).size» turn commands
        - «program.eAllContents.filter(TimeCalculation).size» variable declarations
        - «program.statements.filter(TaskStatus).size» task status checks
        - Total time required (waiting/inprogress): «calculateTotalTime(program)» minutes
        - Total people required: «calculateTotalPeople(program)»
        
        Task Details:
        «FOR task : program.statements.filter(AddTask)»
            - Task name: «task.name»
              Requirement: «task.description»
              Required Time: «getTaskTotalTime(task)» minutes
              Priority: «task.priority»
              Repeat Count: «task.repeatCount» times
              Dependencies: «task.dependencies.map[it.name].join(", ")»
              People Required: «task.peopleRequired» (expression not evaluated)
              Status: «getTaskStatus(program, task)»

        «ENDFOR»
    '''

    def getTaskStatus(TurtleProgram program, AddTask task) {
        val statusStatement = program.statements.filter(TaskStatus).findFirst[it.task.name == task.name]
        if (statusStatement !== null) statusStatement.status.toString() else "unknown"
    }
    
//number of People that All tasks need
// Note: peopleRequired expressions support +, *, group references
// Evaluation logic implemented in evaluate(), but not used here intentionally
    def int calculateTotalPeople(TurtleProgram program) {
        return -1 
    }

// repeat*time
    def double getTaskTotalTime(AddTask task) {
        val repeat = task.repeatCount
        return task.requiredTime * repeat
    }
    
//total time only counting waiting and in_proress
    def double calculateTotalTime(TurtleProgram program) {
        program.statements.filter(AddTask).filter[task |
            val status = getTaskStatus(program, task)
            status == "waiting" || status == "in_progress"
        ].fold(0.0) [ total, task |
            total + getTaskTotalTime(task)
        ]
    }


}