/*
 * generated by Xtext 2.37.0
 */
package uk.ac.kcl.inf.languages.turtles.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurnStatement
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.MoveStatement
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.LoopStatement
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtleProgram
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.VariableDeclaration
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.Addition
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.IntExpression
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.Multiplication
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.IntVarExpression
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.IntLiteral
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.Statement
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurnCommand

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtlesLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		if (resource === null || resource.contents.empty) {
        println("Resource is empty, skipping generation!")
        return
    }
		
		val model = resource.contents.head as TurtleProgram
		println("âœ… Generating file for: " + model)
		
		val fileName = deriveTargetFileNameFor(model, resource)
    println("ğŸ“ Writing to file: " + fileName)
    
		fsa.generateFile(deriveTargetFileNameFor(model, resource), model.doGenerateClass)
		
		val className = resource.deriveClassNameFor
		println("ğŸ“ Writing Java class: " + className + ".java")
		fsa.generateFile(className + '.java', model.doGenerateClass(className))
	}
	
	def deriveTargetFileNameFor(TurtleProgram program, Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}
	
	def deriveClassNameFor(Resource resource) {
		val origName = resource.URI.lastSegment
		
		origName.substring(0, origName.indexOf('.')).toFirstUpper + 'Turtle'
	}
	
	def doGenerateClass(TurtleProgram program) '''
		Program contains:
		
		- Â«program.eAllContents.filter(TurnStatement).sizeÂ» turn commands
		- Â«program.eAllContents.filter(MoveStatement).sizeÂ» move commands
		- Â«program.statements.filter(LoopStatement).sizeÂ» top-level loops
		- Â«program.eAllContents.filter(VariableDeclaration).sizeÂ» variable declarations
		DEBUG: Â«program.eAllContents.toListÂ»
	'''
	
	def String doGenerateClass(TurtleProgram program, String className) '''
		import uk.ac.kcl.inf.szschaler.turtles.library.*
		
		public class Â«classNameÂ» {

			public static void main (String[] args) {
				TurtlesFrame tf = new TurtlesFrame();
				
				Turtle t = new Turtle(tf) {
					@Override
					protected void run() {
						Â«program.statements.map[generateJavaStatement(new Environment)].join('\n')Â»
					}
				};
				
				t.run();
			}
		}
	'''
	
	private static class Environment {
		var int counter = 0
		
		def getFreshVarName() '''iÂ«counter++Â»'''
		
		def exit() { counter-- }
	}
	
	dispatch def String generateJavaStatement(Statement stmt, Environment env) ''''''
	dispatch def String generateJavaStatement(MoveStatement stmt, Environment env) '''moveÂ«stmt.command.getName.toFirstUpperÂ»(Â«stmt.steps.generateJavaExpressionÂ»);'''
	dispatch def String generateJavaStatement(TurnStatement stmt, Environment env) '''rotate(Â«if (stmt.command === TurnCommand.LEFT) {'''-'''}Â»Â«stmt.degreesÂ»);'''
	dispatch def String generateJavaStatement(LoopStatement stmt, Environment env) {
		val freshVarName = env.getFreshVarName
		
		val result = '''
			for (int Â«freshVarNameÂ» = 0; Â«freshVarNameÂ» < Â«stmt.count.generateJavaExpressionÂ»; Â«freshVarNameÂ»++) {
				Â«stmt.statements.map[generateJavaStatement(env)].join('\n')Â»
			}
		'''
		
		env.exit
		
		result
	}
	dispatch def String generateJavaExpression(IntExpression exp) ''''''
	dispatch def String generateJavaExpression(Addition exp) '''
		(Â«exp.left.generateJavaExpressionÂ»Â«FOR idx: (0..exp.operator.size-1)Â» Â«exp.operator.get(idx)Â» Â«exp.right.get(idx).generateJavaExpressionÂ»Â«ENDFORÂ»)'''
	dispatch def String generateJavaExpression(Multiplication exp) '''
		Â«exp.left.generateJavaExpressionÂ»Â«FOR idx: (0..exp.operator.size-1)Â» Â«exp.operator.get(idx)Â» Â«exp.right.get(idx).generateJavaExpressionÂ»Â«ENDFORÂ»'''
	dispatch def String generateJavaExpression(IntLiteral exp) '''Â«exp.^valÂ»'''
	dispatch def String generateJavaExpression(IntVarExpression exp) '''Â«exp.^var.valueÂ»'''
}


