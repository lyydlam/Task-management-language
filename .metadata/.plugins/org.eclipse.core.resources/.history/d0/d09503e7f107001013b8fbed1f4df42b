/*
 * generated by Xtext 2.37.0
 */
package uk.ac.kcl.inf.languages.turtles.generator

import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.AddTask
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.RemoveTask
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TimeCalculation
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TaskStatus
import uk.ac.kcl.inf.languages.turtles.turtlesLanguage.TurtleProgram

/**
 * 负责生成代码（如任务调度逻辑、时间计算等）
 * 代码生成器
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtlesLanguageGenerator extends AbstractGenerator {

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        if (resource.contents.empty || !(resource.contents.head instanceof TurtleProgram)) {
        println("Error: No TurtleProgram found in resource " + resource.URI)
        return
    }
        val program = resource.contents.head as TurtleProgram
        fsa.generateFile(deriveTargetFileNameFor(program, resource), program.doGenerate)
    }

    def deriveTargetFileNameFor(TurtleProgram program, Resource resource) {
        resource.URI.appendFileExtension('txt').lastSegment
    }

    def String doGenerate(TurtleProgram program) '''
        Program contains:
        - «program.eAllContents.filter(AddTask).size» turn commands
        - «program.eAllContents.filter(RemoveTask).size» move commands
        - «program.eAllContents.filter(TimeCalculation).size» variable declarations
        - «program.statements.filter(TaskStatus).size» task status checks
        - Total time required (waiting/inprogress): «calculateTotalTime(program)» minutes
        - Total people required: «calculateTotalPeople(program)»
        
        Task Details:
        «FOR task : program.statements.filter(AddTask)»
            - Task ID: «task.id»
              Name: «task.name»
              Required Time: «getTaskTotalTime(task)» minutes
              Priority: «task.priority»
              Dependencies: «task.dependencies.map[it.id].join(", ")»
              Repeat Count: «task.repeatCount» times
              Status: «getTaskStatus(program, task)»
              People Required: «task.peopleRequired» people
        «ENDFOR»
    '''

    def getTaskStatus(TurtleProgram program, AddTask task) {
        val statusStatement = program.statements.filter(TaskStatus).findFirst[it.task.id == task.id]
        if (statusStatement !== null) statusStatement.status.toString() else "unknown"
    }
    
//number of People that All tasks need
    def int calculateTotalPeople(TurtleProgram program) {
        program.statements.filter(AddTask).fold(0) [ total, task |
            total + (task.peopleRequired)
        ]
    }

// repeat*time
    def double getTaskTotalTime(AddTask task) {
        val repeat = task.repeatCount
        return task.requiredTime * repeat
    }
    
//total time only counting waiting and in_proress
    def double calculateTotalTime(TurtleProgram program) {
        program.statements.filter(AddTask).filter[task |
            val status = getTaskStatus(program, task)
            status == "waiting" || status == "in_progress"
        ].fold(0.0) [ total, task |
            total + getTaskTotalTime(task)
        ]
    }
}

	
	